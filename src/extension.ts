import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as cp from 'child_process';

// Import custom libs
import * as entityUtils from './lib/EntityUtils';
import * as testbenchCommands from './lib/TestbenchCommand';
import * as tomlUtils from './lib/TomlUtils';
import * as quartus from './lib/QuartusUtils';
import * as questa from './lib/QuestaUtils';
import * as compileCommands from './lib/CompileCommand';
import * as testCommands from './lib/TestCommands';
import * as statusBarCreator from './lib/StatusBarUtils';
import * as pathUtils from './lib/PathUtils';
import * as vhdlLang from './lib/VhdlLang';

// Import command creators
import * as generateTestBenchSelection from './commands/generateTestBenchSelection';
import * as generateTestBenchExplorer from './commands/generateTestBenchExplorer';
import * as selectQuartusProject from './commands/selectQuartusProject';
import * as compileCurrentProject from './commands/compileCurrentProject';
import * as analyseElaborateCurrentProject from './commands/analyseElaborateCurrentProject';
import * as cleanCompileFiles from './commands/cleanCompileFiles';
import * as openProgrammerActiveProject from './commands/openProgrammerActiveProject';
import * as openRtlViewerActiveProject from './commands/openRtlViewerActiveProject';
import * as changeTopLevel from './commands/changeTopLevel';
import * as addFileToProjectContext from './commands/addFileToProjectContext'
import * as removeFileFromProjectContext from './commands/removeFileFromProjectContext'

export let outputChannel: vscode.OutputChannel;
export let quartusProjectFilesView: quartus.QuartusProjectFileTreeDataProvider;
export let quartusProjectPropertiesView: quartus.QuartusProjectPropertiesTreeDataProvider;
export let currentQuestaProjectDisplay: vscode.StatusBarItem;
export let runQuestaTestsButton: vscode.StatusBarItem;
export let currentQuartusProjectDisplay: vscode.StatusBarItem;
export let currentTopLevelDisplay: vscode.StatusBarItem;

export async function activate(context: vscode.ExtensionContext): Promise<void> {
	outputChannel = vscode.window.createOutputChannel("VHDL-QQS");

	/**
	 * @brief Command that reloads entire VS Code windows so the extension restarts.
	 * @author BakxY
	 */
	var disposable = vscode.commands.registerCommand('vhdl-qqs.manualActivateExtension', () => {
		vscode.commands.executeCommand('workbench.action.reloadWindow');
	});
	context.subscriptions.push(disposable);

	/**
	 * @brief Command generates a new testbench for a entity. This commands uses the user selected expression as the entity to generate the testbench for.
	 * @author BakxY
	 */
	context.subscriptions.push(generateTestBenchSelection.getCommand(context));

	/**
	 * @brief Command generates a new testbench for a entity. This commands uses the toml file to get available entities and present the user with a menu selection.
	 * @author BakxY
	 */
	context.subscriptions.push(generateTestBenchExplorer.getCommand(context));

	/**
	 * @brief Command sets the currently selected project for the current workspace.
	 * @author BakxY
	 */
	context.subscriptions.push(selectQuartusProject.getCommand(context));

	/**
	 * @brief Commands created and runs a tcl script in the quartus tcl shell that will compile the currently active project.
	 * @author BakxY
	 */
	context.subscriptions.push(compileCurrentProject.getCommand(context));

	/**
	 * @brief Commands created and runs a tcl script in the quartus tcl shell that will analyse and elaborate the currently active project.
	 * @author BakxY
	 */
	context.subscriptions.push(analyseElaborateCurrentProject.getCommand(context));

	/**
	 * @brief Command cleans files that were generated by the compilation of a quartus project.
	 * @author BakxY
	 */
	context.subscriptions.push(cleanCompileFiles.getCommand(context));

	/**
	 * @brief Command opens the quartus fpga programmer for the currently active and compiled project
	 * @author BakxY
	 */
	context.subscriptions.push(openProgrammerActiveProject.getCommand(context));

	/**
	 * @brief Command opens the quartus rtl viewer for currently active project
	 * @author BakxY
	 */
	context.subscriptions.push(openRtlViewerActiveProject.getCommand(context));

	/**
	 * @brief Command changes the current top level entity file of the active project.
	 * @author BakxY
	 */
	context.subscriptions.push(changeTopLevel.getCommand(context));

	/**
	 * @brief Command used in context menu to add a file to the current project.
	 * @author BakxY
	 */
	context.subscriptions.push(addFileToProjectContext.getCommand(context));

	/**
	 * @brief Command used in context menu to remove a file from the current project.
	 * @author BakxY
	 */
	context.subscriptions.push(removeFileFromProjectContext.getCommand(context));

	/**
	 * @brief Command used to remove a file from the current project by a user menu selection.
	 * @author BakxY
	 */
	var disposable = vscode.commands.registerCommand('vhdl-qqs.removeFileFromProject', async () => {
		// Get currently active project
		const activeProject: string | null = await pathUtils.getCurrentQuartusProject(context);
		if (activeProject === null) { return; }

		// Get  quartus install bin path
		const quartusPath: string | null = await pathUtils.getQuartusBinPath();
		if (quartusPath === null) { return; }

		let allProjectFiles: string[] = [];

		allProjectFiles = allProjectFiles.concat(quartus.getProjectVhdlSourceFiles(context, activeProject, quartusPath));
		allProjectFiles = allProjectFiles.concat(quartus.getProjectVerilogSourceFiles(context, activeProject, quartusPath));

		// Ask user to pick a entity
		const fileToRemove: string | undefined = await vscode.window.showQuickPick(allProjectFiles, { title: 'Select a file to remove from project' });
		if (fileToRemove === undefined) { return; }

		switch (path.extname(fileToRemove)) {
			case '.vhd':
				quartus.removeVhdlFileToProject(context, activeProject, quartusPath, fileToRemove);
				break;

			case '.v':
				quartus.removeVerilogFileToProject(context, activeProject, quartusPath, fileToRemove);
				break;
		}

		quartusProjectFilesView.updateData(context, activeProject, quartusPath);
		vscode.window.showInformationMessage('Removed file to active project!');
	});
	context.subscriptions.push(disposable);

	/**
	 * @brief Command used to refresh the data displayed in Quartus Source File list.
	 * @author BakxY
	 */
	var disposable = vscode.commands.registerCommand('vhdl-qqs.refreshSourceFiles', async () => {
		// Get currently active project
		const activeProject: string | null = await pathUtils.getCurrentQuartusProject(context);
		if (activeProject === null) { return; }

		// Get  quartus install bin path
		const quartusPath: string | null = await pathUtils.getQuartusBinPath();
		if (quartusPath === null) { return; }

		quartusProjectFilesView.updateData(context, activeProject, quartusPath);
		vscode.window.showInformationMessage('Refreshed source file list!');
	});
	context.subscriptions.push(disposable);

	/**
	 * @brief Command used to create a new entity from a template file
	 * @author BakxY
	 */
	var disposable = vscode.commands.registerCommand('vhdl-qqs.createNewEntity', async () => {
		// Get currently active project
		const activeProject: string | null = await pathUtils.getCurrentQuartusProject(context);
		if (activeProject === null) { return; }

		// Get  quartus install bin path
		const quartusPath: string | null = await pathUtils.getQuartusBinPath();
		if (quartusPath === null) { return; }



		const entityName: string | undefined = await vscode.window.showInputBox({ title: 'Enter the identifier for the new entity' });
		if (entityName === undefined) { return; }

		if (entityName.endsWith('_tb')) {
			vscode.window.showErrorMessage('Entity name can\'t end in "_tp"! Suffix "_tp" is reserved for testbenches!');
			console.error('Entity name can\'t end in "_tp"! Suffix "_tp" is reserved for testbenches!');
			outputChannel.appendLine('Entity name can\'t end in "_tp"! Suffix "_tp" is reserved for testbenches!');
			return;
		}

		// Get all files included in the current project
		let allProjectFiles: string[] = [];
		allProjectFiles = allProjectFiles.concat(quartus.getProjectVhdlSourceFiles(context, activeProject, quartusPath));
		allProjectFiles = allProjectFiles.concat(quartus.getProjectVerilogSourceFiles(context, activeProject, quartusPath));

		// Check if there already exits a entity with user specified name
		for (let fileIndex = 0; fileIndex < allProjectFiles.length; fileIndex++) {
			if (path.basename(allProjectFiles[fileIndex]).replace(path.extname(allProjectFiles[fileIndex]), '') === entityName) {
				vscode.window.showErrorMessage('There already exists a entity with the name "' + entityName + '" in current project!');
				console.error('There already exists a entity with the name "' + entityName + '" in current project!');
				outputChannel.appendLine('There already exists a entity with the name "' + entityName + '" in current project!');
				return;
			}
		}

		// Ask user where to save the new entity to
		const targetFolder: vscode.Uri[] | undefined = await vscode.window.showOpenDialog({
			canSelectFolders: true,
			canSelectFiles: false,
			canSelectMany: false,
			openLabel: 'Select Folder',
			title: 'Select folder to store the new entity in'
		});
		if (targetFolder === undefined) { return; }

		const targetFilePath = path.join(targetFolder[0].fsPath, entityName + '.vhd');

		// Check if file already exists
		if (fs.existsSync(targetFilePath)) {
			vscode.window.showErrorMessage('Target file already exists at "' + targetFilePath + '"');
			console.error('Target file already exists at "' + targetFilePath + '"');
			outputChannel.appendLine('Target file already exists at "' + targetFilePath + '"');
			return;
		}

		// Generate entire path for template file
		const PATH_TO_ENTITY_TEMPLATE: string = path.join(context.extensionPath, 'res', 'entity_template.vhd');
		console.log('Loading template file from "' + PATH_TO_ENTITY_TEMPLATE + '"');
		outputChannel.appendLine('Loading template file from "' + PATH_TO_ENTITY_TEMPLATE + '"');

		let generatedEntity: string = fs.readFileSync(PATH_TO_ENTITY_TEMPLATE, 'utf-8');

		// Populate template
		generatedEntity = generatedEntity.replaceAll('ENTITY_NAME', entityName);
		generatedEntity = generatedEntity.replaceAll('DATE_CREATED', new Date().toLocaleDateString('de-CH'));

		// Write template to fs
		console.log('Writing template to "' + generatedEntity + '"');
		outputChannel.appendLine('Writing template to "' + generatedEntity + '"');
		fs.writeFileSync(targetFilePath, generatedEntity);

		// Add file to project as source file
		const relativePath = path.relative(path.dirname(path.join(pathUtils.getWorkspacePath()!, activeProject)), targetFilePath).replaceAll('\\', '/');
		quartus.addVhdlFileToProject(context, activeProject, quartusPath, relativePath);

		console.log('Finished creation of entity and added to active project as source file!');
		vscode.window.showInformationMessage('Finished creation of entity and added to active project as source file!');
		outputChannel.appendLine('Finished creation of entity and added to active project as source file!');
	});
	context.subscriptions.push(disposable);

	/**
	 * @brief Command used to select questa project to run tests for
	 * @author BakxY
	 */
	var disposable = vscode.commands.registerCommand('vhdl-qqs.selectQuestaProject', async () => {
		if (!vscode.workspace.getConfiguration('vhdl-qqs').get('questaFeatureFlag')) {
			vscode.window.showErrorMessage('Feature isn\'t enabled!');
			console.error('Feature isn\'t enabled!');
			outputChannel.appendLine('Feature isn\'t enabled!');
			return;
		}

		const availableProjects: string[] = questa.getAllProjectFiles();

		// Check if there are any quartus project file are in current workspace
		if (availableProjects.length === 0) {
			vscode.window.showErrorMessage('There are no project in your workfolder!');
			console.error('There are no project in your workfolder!');
			outputChannel.appendLine('There are no project in your workfolder!');
			return;
		}

		// Ask user to select a project
		const selectedProject: string | undefined = await vscode.window.showQuickPick(availableProjects, { title: 'Select a project' });
		if (selectedProject === undefined) { return; }

		// Update UI elements and update workspace storage
		context.workspaceState.update('vhdl-qqs.currentActiveQuestaProject', selectedProject);
		currentQuestaProjectDisplay.text = 'Questa: ' + path.basename(selectedProject).replace(path.extname(selectedProject), '');
	});
	context.subscriptions.push(disposable);

	/**
	 * @brief Command used to run tests for selected questa project
	 * @author BakxY
	 */
	var disposable = vscode.commands.registerCommand('vhdl-qqs.runQuestaTest', async () => {
		if (!vscode.workspace.getConfiguration('vhdl-qqs').get('questaFeatureFlag')) {
			vscode.window.showErrorMessage('Feature isn\'t enabled!');
			console.error('Feature isn\'t enabled!');
			outputChannel.appendLine('Feature isn\'t enabled!');
			return;
		}

		// Get currently active project
		const activeProject: string | null = await pathUtils.getCurrentQuestaProject(context);
		if (activeProject === null) { return; }

		// Get  quartus install bin path
		const questaPath: string | null = await pathUtils.getQuestaBinPath();
		if (questaPath === null) { return; }

		testCommands.runQuestaTest(context, activeProject, questaPath);
	});
	context.subscriptions.push(disposable);

	/**
	 * @brief Command is called once user clicks on a project property
	 * @author BakxY
	 */
	var disposable = vscode.commands.registerCommand('vhdl-qqs.changeQuartusProjectProperty', async (element) => {
		// Get currently active project
		const activeProject: string | null = await pathUtils.getCurrentQuartusProject(context);
		if (activeProject === null) { return; }

		// Get  quartus install bin path
		const quartusPath: string | null = await pathUtils.getQuartusBinPath();
		if (quartusPath === null) { return; }

		switch (element.name) {
			case 'Device':
			case 'Family':
				const availableFamilies: string[] | null = quartus.getAvailableChipFamilies(context, quartusPath);
				if (availableFamilies === null) { return; }

				const selectedFamily: string | undefined = await vscode.window.showQuickPick(availableFamilies, { title: 'Select a chip family' });
				if (selectedFamily === undefined) { return; }

				const availableChips = quartus.getAvailableChips(context, quartusPath, selectedFamily);
				if (availableChips === null) { return; }

				const selectedChip: string | undefined = await vscode.window.showQuickPick(availableChips, { title: 'Select a chip' });
				if (selectedChip === undefined) { return; }

				quartus.setProjectGlobal(context, activeProject, quartusPath, 'FAMILY', selectedFamily);
				quartus.setProjectGlobal(context, activeProject, quartusPath, 'DEVICE', selectedChip);
				break;

			case 'VHDL Version':
				const availableVhdlVersions = quartus.getAvailableVhdlVersions();

				// Ask user to select a vhdl version
				const selectedVhdlVersion: string | undefined = await vscode.window.showQuickPick(availableVhdlVersions, { title: 'Select a VHDL version' });
				if (selectedVhdlVersion === undefined) { return; }

				quartus.setProjectGlobal(context, activeProject, quartusPath, 'VHDL_INPUT_VERSION', selectedVhdlVersion);
				break;

			case 'Verilog Version':
				const availableVerilogVersions = quartus.getAvailableVerilogVersions();

				// Ask user to select a vhdl version
				const selectedVerilogVersion: string | undefined = await vscode.window.showQuickPick(availableVerilogVersions, { title: 'Select a VHDL version' });
				if (selectedVerilogVersion === undefined) { return; }

				quartus.setProjectGlobal(context, activeProject, quartusPath, 'VERILOG_INPUT_VERSION', selectedVerilogVersion);
				break;

			default:
				break;
		}

		quartusProjectPropertiesView.updateData(context, activeProject, quartusPath);
	});
	context.subscriptions.push(disposable);

	/**
	 * @brief Command that connects and prints device and software information required in bug reports
	 * @author BakxY
	 */
	var disposable = vscode.commands.registerCommand('vhdl-qqs.genDebugDevInfo', async () => {
		outputChannel.appendLine('\nCollected debug information: ')
		outputChannel.appendLine('* OS: ' + process.platform);
		outputChannel.appendLine('* VS Code version: ' + vscode.version);
		outputChannel.appendLine('* Extension version: ' + vscode.extensions.getExtension('bakxy.vhdl-qqs')?.packageJSON.version);

		// Get quartus install bin path
		const quartusPath: string | null = await pathUtils.getQuartusBinPath();
		if (quartusPath === null) {
			outputChannel.appendLine('* Quartus version: not (correctly) configured');
		}
		else
		{
			outputChannel.appendLine('* Quartus version: ' + quartus.checkQuartusVersion(quartusPath));
		}

		outputChannel.show();
	});
	context.subscriptions.push(disposable);


	currentQuartusProjectDisplay = statusBarCreator.createActiveQuartusProject(context);
	context.subscriptions.push(currentQuartusProjectDisplay);

	currentTopLevelDisplay = await statusBarCreator.createChangeTopLevel(context);
	context.subscriptions.push(currentTopLevelDisplay);

	context.subscriptions.push(statusBarCreator.createCleanProject());
	context.subscriptions.push(statusBarCreator.createCompileProject());
	context.subscriptions.push(statusBarCreator.createAnalysisProject());
	context.subscriptions.push(statusBarCreator.createOpenProgrammer());
	context.subscriptions.push(statusBarCreator.createOpenRtlViewer());

	context.subscriptions.push(vscode.workspace.onDidChangeConfiguration(async event => {
		if (event.affectsConfiguration('vhdl-qqs.questaFeatureFlag')) {
			if (vscode.workspace.getConfiguration('vhdl-qqs').get('questaFeatureFlag')) {
				currentQuestaProjectDisplay.show();
				runQuestaTestsButton.show();
			}
			else {
				currentQuestaProjectDisplay.hide();
				runQuestaTestsButton.hide();
			}
		}
		if (event.affectsConfiguration('vhdl-qqs.quartusBinPath')) {
			const quartusPath: string | null = await pathUtils.getQuartusBinPath();

			if (quartusPath !== null) {
				quartus.checkQuartusVersion(quartusPath);
			}
		}
	}));

	currentQuestaProjectDisplay = statusBarCreator.createActiveQuestaProject(context);
	context.subscriptions.push(currentQuestaProjectDisplay);

	runQuestaTestsButton = statusBarCreator.createRunTests();
	context.subscriptions.push(runQuestaTestsButton);

	quartusProjectFilesView = new quartus.QuartusProjectFileTreeDataProvider();
	vscode.window.createTreeView('projectSourceFiles', { treeDataProvider: quartusProjectFilesView });

	quartusProjectPropertiesView = new quartus.QuartusProjectPropertiesTreeDataProvider();
	vscode.window.createTreeView('projectProperties', { treeDataProvider: quartusProjectPropertiesView });

	// Get currently active project
	const activeProject: string | null = await pathUtils.getCurrentQuartusProject(context);
	if (activeProject !== null) {
		// Get  quartus install bin path
		const quartusPath: string | null = await pathUtils.getQuartusBinPath();
		if (quartusPath !== null) {
			quartus.checkQuartusVersion(quartusPath);

			quartusProjectFilesView.updateData(context, activeProject, quartusPath);
			quartusProjectPropertiesView.updateData(context, activeProject, quartusPath);
		}
	}

	vhdlLang.checkDownloadVhdlLang(context);

	context.subscriptions.push(
		vscode.languages.registerDocumentFormattingEditProvider('vhdl', {
			provideDocumentFormattingEdits(document: vscode.TextDocument): vscode.TextEdit[] {
				const edits: vscode.TextEdit[] = [];

				const pathToBin = path.join(context.extensionPath, 'res', 'vhdl_lang');

				if (!vhdlLang.checkForVhdlLang(context)) {
					vscode.window.showErrorMessage('No VHDL_lang executable found! Trying to download VHDL_lang!');
					console.error('No VHDL_lang executable found! Trying to download VHDL_lang!');
					outputChannel.appendLine('No VHDL_lang executable found! Trying to download VHDL_lang!');
					vhdlLang.checkDownloadVhdlLang(context);
					return edits;
				}

				// Save document before formatting it
				document.save();

				const fullRange: vscode.Range = new vscode.Range(0, 0, document.lineCount, 0);
				const execString: string = '"' + pathToBin + '" --format "' + document.uri.fsPath + '"';
				let formattedFile: Buffer<ArrayBufferLike> = Buffer.from([]);

				try {
					formattedFile = cp.execSync(execString);
				}
				catch (err) {
					if (err instanceof Error) {
						const processError = err as (Error & { stderr?: Buffer; stdout?: Buffer });

						console.error('Error while executing "' + execString + '"!\nerror dump:\n' + processError.stdout?.toString());
						outputChannel.appendLine('Error while executing "' + execString + '"!\nerror dump:\n' + processError.stdout?.toString());

						vscode.window.showErrorMessage('You can\'t format a file with broken syntax! Fix syntax before formatting file! Check output to see error!');
						outputChannel.show();
					}
					else {
						console.error('Error while executing "' + execString + '"!\nerror dump:\n' + err);
						outputChannel.appendLine('Error while executing "' + execString + '"!\nerror dump:\n' + err);
						vscode.window.showErrorMessage('Error while executing "' + execString + '"!\nerror dump:\n' + err);
					}

					return edits;
				}

				edits.push(vscode.TextEdit.replace(fullRange, formattedFile.toString()));

				return edits;
			}
		})
	);
}

export function deactivate(): void {

}